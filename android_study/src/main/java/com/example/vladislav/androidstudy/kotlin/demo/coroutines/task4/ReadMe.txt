Реализуйте систему мониторинга прогресса выполнения задач с использованием корутин. Система должна включать:

Долгосрочную задачу (long-running task):Эта задача представляет собой длительный процесс, состоящий из N этапов. Каждое успешное прохождение этапа сопровождается изменением общего прогресса выполнения задачи.
Мониторинг статуса выполнения:Пользовательская корутина запрашивает статус выполнения задачи и получает процент выполненных этапов.
Параллельность и уведомления:Мониторинг и долгосрочная задача должны выполняться параллельно, при этом мониторинг регулярно проверяет статус и уведомляет пользователя о ходе выполнения.
Требования:
Долгосрочная задача состоит из пяти этапов, каждый этап занимает случайное время от 1 до 3 секунд.
Процесс мониторинга проверки статуса должен выполняться раз в полсекунды.
Прогресс выражается в процентах, где 100% означает полное завершение всех этапов.


Ответ Сберчата по решению с каналами (Channels)

Когда в оба класса подавал общий скоуп:
    В текущем виде задача и мониторинг создаются в одном CoroutineScope, что приемлемо, но лучше разместить их в разные области, чтобы управлять ими отдельно, если появится необходимость.

    Когда имеет смысл разделять корутины по отдельным scope?
    Есть несколько ситуаций, когда разделять задачи по разным scope оправдано:
    Независимое управление корутинами:Если у тебя есть разные модули или компоненты, которые хотят иметь независимость в плане управления своим жизненным циклом (например, сервисы, работающие в фоне, или временные задачи).
    Изоляция корутин:В случае, если одна группа корутин должна иметь собственную иерархию и правила завершения, их можно поместить в отдельный scope.
    Обеспечение надежности:Отделяя корутины в разные scope, ты снижаешь риск распространения сбоев между модулями. Если одна группа корутин столкнется с проблемой, это не затронет другие scope.

Могут ли быть улучшения?
    Если рассматривать возможность оптимизации, вот несколько направлений для размышлений:

    Интерфейсы для абстрагирования логики:Если планируется расширение функционала, можно ввести интерфейс для Executor и ProgressChecker, чтобы обеспечить гибкость внедрения различных реализаций.
    interface IExecutor {
        fun executeTask(scope: CoroutineScope, channel: Channel<String>)
    }
    interface IProgressChecker {
        fun checkProgress(scope: CoroutineScope, progressChannel: Channel<String>)
    }
    Композиция вместо наследования:В случае роста проекта можно использовать композицию, внедряя конкретные реализации исполнителей и чекеров через фабричные методы или фабрики классов.
    Архитектурные шаблоны:Рассмотри возможность применения классических архитектурных шаблонов, таких как MVP/MVVM (если разрабатываешь Android-приложение), чтобы улучшить разделение логики и представления.

Пример композиции:

interface IExecutor {
    fun executeTask(scope: CoroutineScope, channel: Channel<String>)
}

class DefaultExecutor : IExecutor {
    override fun executeTask(scope: CoroutineScope, channel: Channel<String>) {
        scope.launch {
            var percentInc = 20
            repeat(5) {
                delay((1000 + random.nextDouble() * 2000).toLong())
                channel.send("Progress: $percentInc%")
                percentInc += 20
            }
            channel.close()
        }
    }
}

interface IProgressChecker {
    fun checkProgress(scope: CoroutineScope, progressChannel: Channel<String>)
}

class DefaultProgressChecker : IProgressChecker {
    override fun checkProgress(scope: CoroutineScope, progressChannel: Channel<String>) {
        scope.launch {
            for (progressValue in progressChannel) {
                delay(500)
                println(progressValue)
                if (progressValue.contains("100")) {
                    println("ProgressChecker finished monitoring")
                    break
                }
            }
        }
    }
}

// Фабрика для создания экземпляров
object Factory {
    fun createExecutor(): IExecutor = DefaultExecutor()
    fun createProgressChecker(): IProgressChecker = DefaultProgressChecker()
}

// Запуск
fun main() = runBlocking {
    val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    val channel = Channel<String>()

    val executor = Factory.createExecutor()
    val checker = Factory.createProgressChecker()

    executor.executeTask(scope, channel)
    checker.checkProgress(scope, channel)

    delay(10_000) // Время на завершение задач. В Андроиде это ожидание не нужно.
}



Ответ Сберчата по решению с SharedFlow:

    Подход с использованием SharedFlow позволяет строить реактивные потоки данных, подходящие для ситуации, когда множественные потребители должны получать доступ к данным в режиме реального времени.

    Использование ленивого запуска:
    Если тебе не обязательно ждать запуска задачи заранее, можно задействовать ленивый запуск (lazyStart = true), чтобы отложить выполнение до реальной необходимости.

Промпт Сберчату:
    Напомни какие подходы ты предлагал изначально.
Ответ Сберчата:
    Три основных подхода:
        Каналы (Channel):
    Использование канала (Channel) для передачи сообщений о прогрессе от исполнителя к монитору.
    Исполнитель отправляет обновления прогресса в канал, а монитор их принимает и обрабатывает.
    Преимущества: Гибкость, легкость реализации, поддержка буферизации.
    Недостатки: Менее эффективен для широковещательных рассылок, может требовать дополнительной синхронизации.
        Общий поток (SharedFlow):
    Совместимый с реактивными моделями программирования, поддерживает восстановление утраченных сообщений.
    Исполнитель публикует прогресс в поток, а монитор подписывается на него и получает обновления.
    Преимущества: Широко поддерживается современными инструментами, удобен для многопоточных приложений.
    Недостатки: Сложнее настройка буферизации и режима доставки сообщений.
        Наследники потоков (StateFlow, CallbackFlow, etc.):
    Эти типы потоков поддерживают особые свойства, такие как хранение последнего значения (StateFlow) или возможность индивидуальной реакции на события (CallbackFlow).
    Используются в случаях, когда нужно особое поведение потока.
    Преимущества: Специфичные особенности, удобные для особых задач.
    Недостатки: Требуют глубокого понимания особенностей потоков и моделей реагирования.

    Другие подходы: Помимо перечисленных выше, существуют и другие методики, заслуживающие внимания:
        BroadcastChannel:
    Специальный вид канала, предназначенный для широковещательной рассылки сообщений нескольким получателям.
    Полезен, если задача предполагает одновременное оповещение множества слушателей.
        LiveData (Jetpack):
    Наблюдательные данные, применяемые в Android для поддержания жизнеспособности представлений (UI).
    Очень полезен для Android-проектов, особенно в сочетании с архитектурой MVVM.
        RxJava (ReactiveX):
    Мощная библиотека для реактивного программирования, позволяющая создавать потоки данных и преобразовывать их в различные формы.
    Отлично интегрируется с Kotlin и корутинами.
        Flow:
    Универсальный инструмент для передачи последовательности значений, основан на концепции корутин.
    Имеет широкий спектр возможностей для трансформации и объединения потоков.
        Callbacks / Events Bus:
    Традиционные подходы, основанные на обратных вызовах и событиях.
    Старый, но рабочий подход, применимый в ряде ситуаций.

    Выбор инструмента:  Каждый подход обладает своими преимуществами и недостатками. Основное правило выбора — это соответствовать требованиям задачи и стилю проекта. Вот кратко рекомендации:
        Небольшие проекты или прототипы: Channel или Flow.
        Проект с широкой аудиторией слушателей: BroadcastChannel или LiveData.
        Сложные преобразования данных: RxJava или специализированные потоки.
        Крупные корпоративные решения: комбинация подходов, адаптированная под бизнес-требования.